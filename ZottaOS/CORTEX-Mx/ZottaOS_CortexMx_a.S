/* Copyright (c) 2006-2012 MIS Institute of the HEIG-VD affiliated to the University of
** Applied Sciences of Western Switzerland. All rights reserved.
** Permission to use, copy, modify, and distribute this software and its documentation
** for any purpose, without fee, and without written agreement is hereby granted, pro-
** vided that the above copyright notice, the following three sentences and the authors
** appear in all copies of this software and in the software where it is used.
** IN NO EVENT SHALL THE MIS INSTITUTE NOR THE HEIG-VD NOR THE UNIVERSITY OF APPLIED
** SCIENCES OF WESTERN SWITZERLAND BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
** INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
** DOCUMENTATION, EVEN IF THE MIS INSTITUTE OR THE HEIG-VD OR THE UNIVERSITY OF APPLIED
** SCIENCES OF WESTERN SWITZERLAND HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
** THE MIS INSTITUTE, THE HEIG-VD AND THE UNIVERSITY OF APPLIED SCIENCES OF WESTERN SWIT-
** ZERLAND SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFT-
** WARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE MIS INSTITUTE NOR THE HEIG-VD
** AND NOR THE UNIVERSITY OF APPLIED SCIENCES OF WESTERN SWITZERLAND HAVE NO OBLIGATION
** TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
*/
/* File ZottaOS_CortexMx_a.S: Holds assembler implemented functions for all Cortex-Mx
**           microcontrollers. For the time being, only context switching is needed.
** Platform version: All Cortex-Mx based microcontrollers.
** Version date: August 2012
** Authors: MIS-TIC */

#define _ASM_

#include "ZottaOS_Config.h"

.syntax unified

/* CONTEXT SWITCHING
**   An interrupt handler executed at the lowest level of priority carries out the con-
**   text switching between the tasks. This is a software interrupt generated by one of
**   the routines that completes a task instance (OSSuspendSynchronousTask and OSEndTask)
**   or from the software timer interrupt (_OSTimerInterruptHandler).
**
** REGISTER SAVING
**   At the time of a Cortex-Mx interruption, the registers given below are automatically
**   saved on the run-time stack, and when returning from an interrupt, these registers
**   are restored in the same manner.
**   Old SP (N)         (Previously pushed data)
**          (N-4)   PSR (Status register)
**          (N-8)   PC  (Program counter)
**          (N-12)  LR  (Link register)
**          (N-16)  R12 (General-purpose register)
**          (N-20)  R3  (General-purpose register)
**          (N-24)  R2  (General-purpose register)
**          (N-28)  R1  (General-purpose register)
**   New SP (N-32)  R0  (General-purpose register)
**   Under ZottaOS, there are two particular scenarios to take care of:
**   (1) When a task instance terminates, the part of the run-time stask occupied by the
**       task must be removed.
**   (2) When a new task instance must be started, the above registers are explicitly
**       placed on the run-time stack so that a return from interruption can be emulated.
**   The other registers (R4-R11 for Cortex-M3 and -M4, or R4-R7 for Cortex-M0) must be
**   explicitly saved by the interrupt handlers if they use them. Note that when the in-
**   terrupt handler is a C function, the compiler automatically generates the necessary
**   code to store and restore these registers. There can be no possible corruption of
**   these registers because the interrupts are prioritized and cannot be aborted. For
**   application tasks, all these registers must be explicitly saved during a context
**   switch because the registers used by the task (a C function) are never restored when
**   the instance finishes.
**   The actions to do depend upon on the state of:
**   (1) _OSActiveTask (always refers to the task at the head of the ready queue) and
**   (2) _OSNoSaveContext which applies to the currently active entity (a task or an ISR
**       that has reached completion or a task that was preempted).
**
**     +--------------------------+-------------------------+------------------------+
**     | _OSActiveTask->TaskState |    = STATE_RUNNING      |     = STATE_INIT       |
**     +--------------------------+-------------------------+------------------------+
**     | _OSNoSaveContext = TRUE  | wipe out the stack of   | wipe out the stack of  |
**     |                          | the currently executing | the current executing  |
**     |                          | entity and return to a  | entity and start a new |
**     |                          | preempted task          | task                   |
**     +--------------------------+-------------------------+------------------------+
**     |_OSNoSaveContext = FALSE  | restore preempted task  | save manual registers  |
**     |                          |                         | and start a new task   |
**     +--------------------------+-------------------------+------------------------+
**
**   _OSContextSwapHandler basically implements the following pseudo code:
**    1. push automatically saved registers onto the stack (done by processor at entry)
**    2. if _OSNoSaveContext then
**          _OSNoSaveContext := false
**          SP := _OSStackBasePointer   (clear stack)
**          if _OSActiveTask->TaskState = STATE_RUNNING then
**             restore previous _OSStackBasePointer
**             pop manually saved registers
**          else
**             _OSActiveTask->TaskState := STATE_RUNNING
**             set new LR, PC, and SR
**             create a minimal context composed of the automatically saved registers
**          end if
**       else if _OSActiveTask->TaskState != STATE_RUNNING then
**          push manually saved registers R4-R11 or R4-R7  (context of previous task)
**          push _OSStackBasePointer           (_OSStackBasePointer of previous task)
**          _OSStackBasePointer := SP
**          set new LR, PC, and SR
**          create a minimal context composed of the automatically saved registers
**       end if
**    3. pop automatically saved registers from the stack (done by processor at exit) */

/* Exported functions */
.global _OSContextSwapHandler

/* Global variables used */
.extern _OSNoSaveContext
.extern _OSStackBasePointer
.extern _OSActiveTask
#if defined(CORTEX_M0)
.extern _OSLLReserveBit;
#endif


#if defined(CORTEX_M3) || defined(CORTEX_M4)
/* _OSContextSwapHandler: Last part of a return from the timer interrupt or from the end
** of an application task. This interrupt is done at the lowest priority and resumes or
** starts executing the next task in the ready queue.
** We always save the context of the current task before starting a new task or resuming
** it. If the _OSNoSaveContext flag is set or if the state of _OSActiveTask is not equal
** to STATE_INIT then there is no need to save the context of the currently active task,
** and in the latter case, we simply have to resume it.
** Contents of the run-time stack when this function is called:
** SP ->                           Local variables of the interrupted or terminated task
**                                   ...
** _OSStackBasePointer ->          previous _OSStackBasePointer         // Manually saved
**                                 R4 - R11 (General-purpose registers) // Manually saved
**                                 R0  (General-purpose register)  // Automatically saved
**                                 R1  (General-purpose register)  // Automatically saved
**                                 R2  (General-purpose register)  // Automatically saved
**                                 R3  (General-purpose register)  // Automatically saved
**                                 R12 (General-purpose register)  // Automatically saved
**                                 LR  (Link register)             // Automatically saved
**                                 PC  (Program counter)           // Automatically saved
**                                 PSR (Status register)           // Automatically saved
**                                 Local variables of the next preempted task
**                                   ...
** previous _OSStackBasePointer -> previous previous _OSStackBasePointer */
.text
.thumb_func
_OSContextSwapHandler:
  LDR R0,=_OSNoSaveContext                 ; R0 <- addr(_OSNoSaveContext)
  LDR R2,=_OSStackBasePointer              ; R2 <- addr(_OSStackBasePointer)
  LDR R1,=_OSActiveTask                    ; R1 <- addr(_OSActiveTask)
  LDR R1,[R1]                              ; R1 <- _OSActiveTask
  /* Is caller with _OSNoSaveContext? */
  LDRB R3,[R0]                             ; R3 <- _OSNoSaveContext
  CBNZ R3,_OSContextSwapHandler_ClearStack ; Jump if _OSNoSaveContext = TRUE
  /* Is active task state RUNNING?*/
  LDRB R0,[R1,#8]                          ; R0 <- _OSActiveTask->TaskState
  AND R3,R0,#1                             ; R3 <- R0 & STATE_RUNNING
  CBNZ R3,_OSContextSwapHandler_End        ; Jump if _OSActiveTask is STATE_RUNNING
  /* Save the context of the task: context switching from an active task to a new task */
  LDR R3,[R2]                              ; R3 <- _OSStackBasePointer
  PUSH {R3,R4-R11}                         ; push R4-R11 and _OSStackBasePointer
  MRS R3,MSP                               ; retrieve SP: R3 <- SP
  STR R3,[R2]                              ; _OSStackBasePointer <- SP
  B _OSContextSwapHandler_CreateNewContext
.thumb_func
_OSContextSwapHandler_ClearStack:
  /* Set _OSNoSaveContext to FALSE */
  MOV R3,#0                                ; R3 <- FALSE
  STRB R3,[R0]                             ; _OSNoSaveContext <- 0
  /* Clear stack */
  LDR R3,[R2]                              ; R3 <- _OSStackBasePointer
  MSR MSP,R3                               ; SP <- _OSStackBasePointer
  /* Is active task state STATE_RUNNING? */
  LDRB R0,[R1,#8]                          ; R0 <- _OSActiveTask->TaskState
  AND R3,R0,#1                             ; R3 <- R0 & STATE_RUNNING
  CBNZ R3,_OSContextSwapHandler_RestoreContext ; Jump if _OSActiveTask is STATE_RUNNING
.thumb_func
_OSContextSwapHandler_CreateNewContext:
  /* Set the state of the new task to STATE_RUNNING */
  ORR R0,R0,#1                             ; R0 (= _OSActiveTask->TaskState) |= STATE_RUNNING
  STRB R0,[R1,#8]                          ; _OSActiveTask->TaskState <- R0
  /* Create a new context on the stack */
#if defined(ZOTTAOS_VERSION_SOFT) && SCHEDULER_REAL_TIME_MODE == DEADLINE_MONOTONIC_SCHEDULING
  LDR R2,[R1,#20]                          ; R2 <- task entry point
  LDR R0,[R1,#24]                          ; R0 <- task argument
#else
  LDR R2,[R1,#16]                          ; R2 <- task entry point
  LDR R0,[R1,#20]                          ; R0 <- task argument
#endif
  /* Set link register to return to thread mode and on return use the main stack */
  MOV R1,#0xFFFFFFF9                       ; R1 <- new LR
  /* Set status register to thumb state */
  MOV R3,#0x01000000                       ; R3 <- new PSR
  /* Push automatically saved registers */
  PUSH {R1-R3}                             ; R1(LR), R2(entry point=PC), R3(PSR)
  PUSH {R0-R3,R12}                         ; R0(task argument), R1-R3 & R12(empty)
  B _OSContextSwapHandler_End
.thumb_func
_OSContextSwapHandler_RestoreContext:
  /* Pop manually saved registers */
  POP {R0,R4-R11}                          ; R0 = previous _OSStackBasePointer
  STR R0,[R2]                              ; _OSStackBasePointer <- R0
.thumb_func
_OSContextSwapHandler_End:
  CLREX                                    ; Make all pending SC() fail
  BX LR
  NOP
/* end of _OSContextSwapHandler */
.end
#elif defined(CORTEX_M0)
/* _OSContextSwapHandler: Same as for Cortex-M3 and Cortex-M4 except that the manually
** saved general purpose registers are R4 - R7 instead of R4 - R11, and there are minor
** assembler changes, e.g. MOV becomes MOVS, etc.
** Contents of the run-time stack when this function is called:
** SP ->                           Local variables of the interrupted or terminated task
**                                   ...
** _OSStackBasePointer ->          previous _OSStackBasePointer         // Manually saved
**                                 R4 - R7 (General-purpose registers)  // Manually saved
**                                 R0  (General-purpose register)  // Automatically saved
**                                 R1  (General-purpose register)  // Automatically saved
**                                 R2  (General-purpose register)  // Automatically saved
**                                 R3  (General-purpose register)  // Automatically saved
**                                 R12 (General-purpose register)  // Automatically saved
**                                 LR  (Link register)             // Automatically saved
**                                 PC  (Program counter)           // Automatically saved
**                                 PSR (Status register)           // Automatically saved
**                                 Local variables of the next preempted task
**                                   ...
** previous _OSStackBasePointer -> previous previous _OSStackBasePointer */
.text
.thumb_func
_OSContextSwapHandler:
  LDR R0,=_OSNoSaveContext                 ; R0 <- addr(_OSNoSaveContext)
  LDR R2,=_OSStackBasePointer              ; R2 <- addr(_OSStackBasePointer)
  LDR R1,=_OSActiveTask                    ; R1 <- addr(_OSActiveTask)
  LDR R1,[R1]                              ; R1 <- _OSActiveTask
  /* Is caller with _OSNoSaveContext? */
  LDRB R3,[R0]                             ; R3 <- _OSNoSaveContext
  CMP R3,#1                                ; is R3 = TRUE?
  BEQ _OSContextSwapHandler_ClearStack     ;   Yes: jump
  /* Is active task state RUNNING?*/
  LDRB R0,[R1,#8]                          ; R0 <- _OSActiveTask->TaskState
  MOVS R3,#1                               ; R3 <- STATE_RUNNING (= 1)
  ANDS R0,R3                               ; R0 <- R0 & STATE_RUNNING
  BNE _OSContextSwapHandler_End            ; Jump if _OSActiveTask is STATE_RUNNING
  /* Save the context of the task: context switching from an active task to a new task */
  LDR R3,[R2]                              ; R3 <- _OSStackBasePointer
  PUSH {R3,R4-R7}                          ; push R4-R11 and _OSStackBasePointer
  MRS R3,MSP                               ; retrieve SP: R3 <- SP
  STR R3,[R2]                              ; _OSStackBasePointer <- SP
  B _OSContextSwapHandler_CreateNewContext
.thumb_func
_OSContextSwapHandler_ClearStack:
  /* Set _OSNoSaveContext to FALSE */
  MOVS R3,#0                               ; R3 <- FALSE
  STRB R3,[R0]                             ; _OSNoSaveContext <- 0
  /* Clear Stack */
  LDR R3,[R2]                              ; R3 <- _OSStackBasePointer
  MSR MSP,R3                               ; SP <- _OSStackBasePointer
  /* Is active task state STATE_RUNNING? */
  LDRB R0,[R1,#8]                          ; R0 <- _OSActiveTask->TaskState
  MOVS R3,#1                               ; R3 <- STATE_RUNNING
  ANDS R0,R3                               ; R0 <- R0 & STATE_RUNNING
  BNE _OSContextSwapHandler_RestoreContext ; Jump if _OSActiveTask is STATE_RUNNING
.thumb_func
_OSContextSwapHandler_CreateNewContext:
  /* Set the state of the new task to STATE_RUNNING */
  MOVS R3,#1                               ; R3 <- STATE_RUNNING
  ORRS R0,R0,R3                            ; R0 (= _OSActiveTask->TaskState) |= STATE_RUNNING
  STRB R0,[R1,#8]                          ; _OSActiveTask->TaskState <- R0
  /* Create a new context on the stack */
#if defined(ZOTTAOS_VERSION_SOFT) && SCHEDULER_REAL_TIME_MODE == DEADLINE_MONOTONIC_SCHEDULING
  LDR R2,[R1,#20]                          ; R2 <- task entry point
  LDR R0,[R1,#24]                          ; R0 <- task argument
#else
  LDR R2,[R1,#16]                          ; R2 <- task entry point
  LDR R0,[R1,#20]                          ; R0 <- task argument
#endif
  /* Set link register to return to thread mode and on return use the main stack (0xFFFFFFF9) */
  MOVS R1,#0
  SUBS R1,R1,#7                            ; R0 <- 0 - 7 = 0xFFFFFFF9
  /* Set status register to thumb state (0x01000000) */
  MOVS R3,#1
  LSLS R3, R3,#24                          ; R3 <- 1 << 24 = 0x01000000  
  /* Push automatically saved registers */
  PUSH {R1-R3}                             ; R1(LR), R2(entry point=PC), R3(PSR)
  PUSH {R0-R3,R4}                          ; R0(task argument), R1-R3 & R4(empty)
  B _OSContextSwapHandler_End
.thumb_func
_OSContextSwapHandler_RestoreContext:
  /* Pop manually saved registers */
  POP {R0,R4-R7}                           ; R0 = previous _OSStackBasePointer
  STR R0,[R2]                              ; _OSStackBasePointer <- R0
.thumb_func
_OSContextSwapHandler_End:
  /* Make all pending SC() fail */
  LDR R0,=_OSLLReserveBit                  ; R0 <- addr(_OSLLReserveBit)
  MOVS R3,#0                               ; R3 <- FALSE
  STRB R3,[R0]                             ; _OSLLReserveBit <- FALSE
  BX LR
  NOP
/* end of _OSContextSwapHandler */
.end
#endif
