/* Copyright (c) 2006-2012 MIS Institute of the HEIG-VD affiliated to the University of
** Applied Sciences of Western Switzerland. All rights reserved.
** Permission to use, copy, modify, and distribute this software and its documentation
** for any purpose, without fee, and without written agreement is hereby granted, pro-
** vided that the above copyright notice, the following three sentences and the authors
** appear in all copies of this software and in the software where it is used.
** IN NO EVENT SHALL THE MIS INSTITUTE NOR THE HEIG-VD NOR THE UNIVERSITY OF APPLIED
** SCIENCES OF WESTERN SWITZERLAND BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
** INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
** DOCUMENTATION, EVEN IF THE MIS INSTITUTE OR THE HEIG-VD OR THE UNIVERSITY OF APPLIED
** SCIENCES OF WESTERN SWITZERLAND HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
** THE MIS INSTITUTE, THE HEIG-VD AND THE UNIVERSITY OF APPLIED SCIENCES OF WESTERN SWIT-
** ZERLAND SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFT-
** WARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE MIS INSTITUTE NOR THE HEIG-VD
** AND NOR THE UNIVERSITY OF APPLIED SCIENCES OF WESTERN SWITZERLAND HAVE NO OBLIGATION
** TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
*/
/* File ZottaOS_CortexMx_a.S: Holds assembler implemented functions for all Cortex-Mx
                              microcontrollers.
** Version date: March 2012
** Authors: MIS-TIC */

#define _ASM_

#include "ZottaOS_Config.h"

.syntax unified

/* INTERRUPTS AND CONTEXT SWITCHING FOR NTRTOS ON CORTEX-Mx TIMER INTERRUPTS
**   The NTRTOS kernel requires a timer that can generate interruptions at variable in-
**   tervals to determine the moments at which the various tasks will be carried out.
**   The timer interrupts must have a higher priority level than all peripheral inter-
**   ruptions whose processing is longer than the time needed to do a full wraparound of
**   the timer counter. If this condition is not met, the internal temporal timings will
**   be wrong. If the processing time a peripheral interrupt can be done in less time
**   than it takes to wraparound the timer, the priority level of the peripheral can be
**   higher compared to that of the timer.
**   To reduce the latency caused by the timer interrupts onto peripheral interrupts, the
**   timer interrupt generates a software interruption (software interruption of the
**   timer) whose priority is weaker. This software interrupt (TimerInterruptHandler)
**   basically processes task arrival times.
**   A timer interrupt is thus done in 2 stages: (1) recuperate the interruption, adjust
**   the time and then (2) propagate it to another at a weaker priority level for its
**   processing.
**
** SUMMARY OF THE INTERRUPTS AND THEIR PRIORITY LEVELS
**   HIGHEST PRIORITY LEVEL
**      Peripheral interrupt handlers (whose execution time cannot be longer than the
**             time to wraparound the timer counter, otherwise the temporal basis will be
**             lost.)
**      Timer interrupt handler (Fixed by TIMER_PRIORITY in NTRTOS_CortexMx.c)
**      Peripheral interrupt handlers (whose execution time can be longer than the wrap-
**             around of the timer. The latency of these interrupts is increased because
**             of possible interrupt executions.)
**      Software timer interrupt handler (Lowest priority level + 1.) (SysTick is used as
**             a software interrupt for NTRTOS)
**      Context switch interrupt handler (executed at the lowest level of priority.)
**             (PendSV)
**   LOWEST PRIORITY LEVEL
**
** CONTEXT SWITCHING
**   An interrupt handler executed at the lowest level of priority carries out the con-
**   text switching between the tasks. This is a software interrupt generated by one of
**   the routines that completes a task instance (OSSuspendSynchronousTask and OSEndTask)
**   or from the software timer interrupt (TimerInterruptHandler).
**
** REGISTER SAVING
**   At the time of a Cortex-Mx interruption, the registers given below are automatically
**   saved on the run-time stack, and when returning form an interrupt, these registers
**   are restored in same manner.
**   Old SP (N)         (Previously pushed data)
**          (N-4)   PSR (Status register)
**          (N-8)   PC  (Program counter)
**          (N-12)  LR  (Link register)
**          (N-16)  R12 (General-purpose register)
**          (N-20)  R3  (General-purpose register)
**          (N-24)  R2  (General-purpose register)
**          (N-28)  R1  (General-purpose register)
**   New SP (N-32)  R0  (General-purpose register)
**
**   Under NTRTOS, there are two particular scenarios to take care of:
**   (1) When a task instance terminates, the part of the run-time task occupied by the
**       task must be removed.
**   (2) When a new task instance must be started, the above registers are explicitly
**       placed on the run-time stack so that a return from interruption can be emulated.
**   The other registers (R4-R11) must be explicitly saved by the interrupt handlers if
**   they use them. Note that when the interrupt handler is a C function, the compiler
**   automatically generates the necessary code to store and restore these registers.
**   There can be no possible corruption of these registers because the interrupts are
**   prioritized and cannot be aborted. For application tasks, all these registers must
**   be explicitly saved during a context switch because the registers used by the task
**   (a C function) are never restored when the instance finishes. */


/* Exported functions */
.global _OSContextSwapHandler

/* Global variables used */
.extern _OSNoSaveContext
.extern _OSStackBasePointer
.extern _OSActiveTask
#if defined(CORTEX_M0)
.extern _OSLLReserveBit;
#endif


#if defined(CORTEX_M3) || defined(CORTEX_M4)
/* _OSContextSwapHandler: Last part of a return from the timer interrupt or from the end
** of an application task. This interrupt is done at the lowest priority and resumes or
** starts executing the next task in the ready queue.
** we always save the context of the current task before starting a new task or resuming
** it. If the _OSNoSaveContext flag is set or if the state of _OSActiveTask is not equal
** to STATE_INIT then there is no need to save the context of the currently active task,
** and in the latter case, we simply have to resume it.
** Contents of the run-time stack when this function is called:
** SP ->                           Local variables of the interrupted or terminated task
**                                   ...
** _OSStackBasePointer ->          previous _OSStackBasePointer         // Manually saved
**                                 R4 - R11 (General-purpose registers) // Manually saved
**                                 R0  (General-purpose register)  // Automatically saved
**                                 R1  (General-purpose register)  // Automatically saved
**                                 R2  (General-purpose register)  // Automatically saved
**                                 R3  (General-purpose register)  // Automatically saved
**                                 R12 (General-purpose register)  // Automatically saved
**                                 LR  (Link register)             // Automatically saved
**                                 PC  (Program counter)           // Automatically saved
**                                 PSR (Status register)           // Automatically saved
**                                 Local variables of the next preempted task
**                                   ...
** previous _OSStackBasePointer -> previous previous _OSStackBasePointer */
.text
.thumb_func
_OSContextSwapHandler:
  /* Check if the context must be saved? */
  LDR R0,=_OSNoSaveContext
  LDR R2,=_OSStackBasePointer
  LDR R1,=_OSActiveTask
  LDR R1,[R1]
  LDRB R3,[R0]
  CBNZ R3,_OSContextSwapHandler_ClearStack   /* Jump if _OSNoSaveContext = TRUE */
  /* Check Active Task State is RUNNING?*/
  LDRB R0,[R1,#8]
  AND R3,R0,#1
  CBNZ R3,_OSContextSwapHandler_End /* Jump if _OSActiveTask is RUNNING */
  /* Save the context of the task */
  LDR R3,[R2]
  PUSH {R3,R4-R11}    /* R3 is previous _OSStackBasePointer */
  MRS R3,MSP          /* Retreive SP */
  STR R3,[R2]         /* Update _OSStackBasePointer */
  B _OSContextSwapHandler_CreateNewContext
.thumb_func
_OSContextSwapHandler_ClearStack:
  /* Set _OSNoSaveContext to FALSE */
  MOV R3,#0
  STRB R3,[R0]
  /* Clear Stack */
  LDR R3,[R2]
  MSR MSP,R3
  /* Check Active Task State is RUNNING?*/
  LDRB R0,[R1,#8]
  AND R3,R0,#1
  CBNZ R3,_OSContextSwapHandler_RestorContext /* Jump if _OSActiveTask is RUNNING */
.thumb_func
_OSContextSwapHandler_CreateNewContext:
  /* Set the state of the new task to RUNNING */
  ORR R0,R0,#1
  STRB R0,[R1,#8]
  /* Create a new context on the stack */
  /* Set task entry point and task argument */
#if defined(ZOTTAOS_VERSION_SOFT) && SCHEDULER_REAL_TIME_MODE == DEADLINE_MONOTONIC_SCHEDULING
  /* Retrieve task entry point */
  LDR R2,[R1,#20]
  /* Retrieve task argument */
  LDR R0,[R1,#24]
#else
  /* Retrieve task entry point */
  LDR R2,[R1,#16]
  /* Retrieve task argument */
  LDR R0,[R1,#20]
#endif
  /* Set link register */
  MOV R1,#0xFFFFFFF9
  /* Set status register */
  MOV R3,#0x01000000
  /* Push Automatically saved registers */
  PUSH {R1-R3}       /* R1(LR), R2(entry point), R3(PSR) */
  PUSH {R0-R3,R12}   /* R0(task argument), R1-R3 & R12(empty) */
  B _OSContextSwapHandler_End
.thumb_func
_OSContextSwapHandler_RestorContext:
  POP {R0,R4-R11}    /* R0 for previous StackBasePointer */
  STR R0,[R2]        /* Update StackBasePointer */
.thumb_func
_OSContextSwapHandler_End:
  /* Make all pending SC() fail */
  CLREX
  BX LR
  NOP
/* end of _OSContextSwapHandler */
.end
#elif defined(CORTEX_M0)
/* _OSContextSwapHandler: Last part of a return from the timer interrupt or from the end
** of an application task. This interrupt is done at the lowest priority and resumes or
** starts executing the next task in the ready queue.
** we always save the context of the current task before starting a new task or resuming
** it. If the _OSNoSaveContext flag is set or if the state of _OSActiveTask is not equal
** to STATE_INIT then there is no need to save the context of the currently active task,
** and in the latter case, we simply have to resume it.
** Contents of the run-time stack when this function is called:
** SP ->                           Local variables of the interrupted or terminated task
**                                   ...
** _OSStackBasePointer ->          previous _OSStackBasePointer         // Manually saved
**                                 R4 - R7 (General-purpose registers)  // Manually saved
**                                 R0  (General-purpose register)  // Automatically saved
**                                 R1  (General-purpose register)  // Automatically saved
**                                 R2  (General-purpose register)  // Automatically saved
**                                 R3  (General-purpose register)  // Automatically saved
**                                 R12 (General-purpose register)  // Automatically saved
**                                 LR  (Link register)             // Automatically saved
**                                 PC  (Program counter)           // Automatically saved
**                                 PSR (Status register)           // Automatically saved
**                                 Local variables of the next preempted task
**                                   ...
** previous _OSStackBasePointer -> previous previous _OSStackBasePointer */
.text
.thumb_func
_OSContextSwapHandler:
  /* Check if the context must be saved? */
  LDR R0,=_OSNoSaveContext
  LDR R2,=_OSStackBasePointer
  LDR R1,=_OSActiveTask
  LDR R1,[R1]
  LDRB R3,[R0]
  CMP R3,#1
  BEQ _OSContextSwapHandler_ClearStack   /* Jump if _OSNoSaveContext = TRUE */
  /* Check Active Task State is RUNNING?*/
  LDRB R0,[R1,#8]
  MOVS R3,#1
  ANDS R0,R3
  BNE _OSContextSwapHandler_End /* Jump if _OSActiveTask is RUNNING */
  /* Save the context of the task */
  LDR R3,[R2]
  PUSH {R3,R4-R7}     /* R3 is previous _OSStackBasePointer */
  MRS R3,MSP          /* Retreive SP */
  STR R3,[R2]         /* Update _OSStackBasePointer */
  B _OSContextSwapHandler_CreateNewContext
.thumb_func
_OSContextSwapHandler_ClearStack:
  /* Set _OSNoSaveContext to FALSE */
  MOVS R3,#0
  STRB R3,[R0]
  /* Clear Stack */
  LDR R3,[R2]
  MSR MSP,R3
  /* Check Active Task State is RUNNING?*/
  LDRB R0,[R1,#8]
  MOVS R3,#1
  ANDS R0,R3
  BNE _OSContextSwapHandler_RestorContext /* Jump if _OSActiveTask is RUNNING */
.thumb_func
_OSContextSwapHandler_CreateNewContext:
  /* Set the state of the new task to RUNNING */
  MOVS R3,#1
  ORRS R0,R0,R3
  STRB R0,[R1,#8]
  /* Create a new context on the stack */
  /* Set task entry point and task argument */
#if defined(ZOTTAOS_VERSION_SOFT) && SCHEDULER_REAL_TIME_MODE == DEADLINE_MONOTONIC_SCHEDULING
  /* Retrieve task entry point */
  LDR R2,[R1,#20]
  /* Retrieve task argument */
  LDR R0,[R1,#24]
#else
  /* Retrieve task entry point */
  LDR R2,[R1,#16]
  /* Retrieve task argument */
  LDR R0,[R1,#20]
#endif
  /* Set link register to 0xFFFFFFF9 */
  MOVS R1,#0
  SUBS R1,R1,#7
  /* Set status register to 0x01000000 */
  MOVS r3,#1
  LSLS r3, r3,#24
  /* Push Automatically saved registers */
  PUSH {R1-R3}       /* R1(LR), R2(entry point), R3(PSR) */
  PUSH {R0-R3,R4}    /* R0(task argument), R1-R3 & R12(empty) */
  B _OSContextSwapHandler_End
.thumb_func
_OSContextSwapHandler_RestorContext:
  POP {R0,R4-R7}     /* R0 for previous StackBasePointer */
  STR R0,[R2]        /* Update StackBasePointer */
.thumb_func
_OSContextSwapHandler_End:
  /* Make all pending SC() fail */
  LDR R0,=_OSLLReserveBit
  MOVS R3,#0
  STRB R3,[R0]
  BX LR
  NOP
/* end of _OSContextSwapHandler */
.end
#endif
